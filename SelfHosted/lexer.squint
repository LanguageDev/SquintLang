import System.Linq.Enumerable.Range;

#[derive(Equatable, ToString)]
type Span(val From: int, val To: int);

#[derive(Equatable, ToString)]
type TokenType =
    // End of input
    | End
    // Unknown
    | Unknown

    // Trivia
    | Whitespace
    | LineComment

    // Binary operators
    | OpAdd | OpSub | OpMul | OpDiv | OpMod | OpRem
    // Assignment operators
    | OpAsgn | OpAddAsgn | OpSubAsgn | OpMulAsgn | OpDivAsgn
    // Comparison operators
    | OpEq | OpNeq | OpLt | OpLte | OpGt | OpGte | KwIn
    // Logical operators
    | OpAnd | OpOr | OpNot

    // Punctuation
    | Dot | Comma | Colon | SemiColon | Hash | Pipe | Arrow

    // Pairwise
    | OpenParen | CloseParen
    | OpenBrace | CloseBrace
    | OpenBracket | CloseBracket

    // Keywords
    | KwImport
    | KwType | KwTrait | KwFunc | KwVar | KwVal
    | KwIf | KwElse | KwFor | KwWhile | KwReturn | KwMatch | KwGoto
    | KwCast | KwThis | KwImpl
    | KwTrue | KwFalse

    // Names and literals
    | Discard
    | Name
    | LitInt | LitChar
    // String literal components
    | LitStrStart | LitStrEnd
    | LitStrElement | LitStrDollar | LitStrName
    | LitStrOpenCurly | LitStrCloseCurly
    ;

#[derive(ToString)]
type Token(val Text: string, val Kind: TokenType, val Span: Span);

type Lexer(val Text: string, var Offset: int);

impl Lexer {
    // NOTE: Named arguments would be really nice here
    // Maybe Lexer(Text = text, Offset = 0) ?
    func new(text: string): Lexer = Lexer(text, 0);

    func next(this): Token {
        var start = this.Offset;

        func is_end(): bool = this.Offset >= this.Text.Length;
        func current(): char = this.Text[this.Offset];
        func step() = this.Offset += 1;

        func consume_while(pred: (char) -> bool) {
            while (not is_end() and pred(current())) step();
        }

        func take(ty: TokenType): Token {
            val text = this.Text.Substring(start, this.Offset - start);
            val span = Span(start, this.Offset);
            return Token(text, ty, span);
        }

        func matches(text: string): bool {
            if (this.Offset + text.Length > this.Text.Length) return false;
            for (i in Range(0, text.Length)) {
                if (text[i] != this.Text[this.Offset + i]) return false;
            }
            this.Offset += text.Length;
            return true;
        }

        func is_ident(ch: char): bool = char.IsLetterOrDigit(ch) or ch == '_';
        func is_end_of_line(ch: char): bool = ch == '\n' or ch == '\r';
        func negate(pred: (char) -> bool): (char) -> bool {
            func f(ch: char): bool = not pred(ch);
            return f;
        }

        // EOF
        if (is_end()) return take(TokenType.End);

        // Space
        if (char.IsWhiteSpace(current())) {
            consume_while(char.IsWhiteSpace);
            return take(TokenType.Whitespace);
        }

        // Line comment
        if (matches("//")) {
            consume_while(negate(is_end_of_line));
            return take(TokenType.LineComment);
        }

        // Two-character tokens are handled first, so one character tokens won't
        // split them
        if (matches("==")) return take(TokenType.OpEq);
        if (matches("!=")) return take(TokenType.OpNeq);
        if (matches(">=")) return take(TokenType.OpGte);
        if (matches("<=")) return take(TokenType.OpLte);
        if (matches("+=")) return take(TokenType.OpAddAsgn);
        if (matches("-=")) return take(TokenType.OpSubAsgn);
        if (matches("*=")) return take(TokenType.OpMulAsgn);
        if (matches("/=")) return take(TokenType.OpDivAsgn);
        if (matches("->")) return take(TokenType.Arrow);

        // Integer literal
        if (char.IsDigit(current())) {
            consume_while(char.IsDigit);
            return take(TokenType.LitInt);
        }

        // Identifier-like tokens
        if (is_ident(current())) {
            consume_while(is_ident);
            val result = take(TokenType.Name);
            val kind = match (result.Text) {
            | "import" -> TokenType.KwImport
            | "func" -> TokenType.KwFunc
            | "var" -> TokenType.KwVar
            | "val" -> TokenType.KwVal
            | "type" -> TokenType.KwType
            | "trait" -> TokenType.KwTrait
            | "this" -> TokenType.KwThis
            | "return" -> TokenType.KwReturn
            | "goto" -> TokenType.KwGoto
            | "for" -> TokenType.KwFor
            | "impl" -> TokenType.KwImpl
            | "if" -> TokenType.KwIf
            | "else" -> TokenType.KwElse
            | "while" -> TokenType.KwWhile
            | "match" -> TokenType.KwMatch
            | "cast" -> TokenType.KwCast
            | "in" -> TokenType.KwIn
            | "true" -> TokenType.KwTrue
            | "false" -> TokenType.KwFalse
            | "mod" -> TokenType.OpMod
            | "rem" -> TokenType.OpRem
            | "and" -> TokenType.OpAnd
            | "or" -> TokenType.OpOr
            | "not" -> TokenType.OpNot
            | "_" -> TokenType.Discard
            | _ -> TokenType.Name
            };
            return Token(result.Text, kind, result.Span);
        }

        // Unknown
        step();
        return take(TokenType.Unknown);
    }
}
