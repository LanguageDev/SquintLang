import System.Collections.Generic.Stack[T];
import System.Collections.Generic.IEnumerable[T];
import System.Collections.Generic.List[T];
import System.Linq.Enumerable.Range;
import System.NotImplementedException;

#[derive(Equatable, ToString)]
type TokenType =
    // End of input
    | End
    // Unknown
    | Unknown

    // Trivia
    | Whitespace
    | Newline
    | LineComment

    // Binary operators
    | OpAdd | OpSub | OpMul | OpDiv | OpMod | OpRem
    // Assignment operators
    | OpAsgn | OpAddAsgn | OpSubAsgn | OpMulAsgn | OpDivAsgn
    // Comparison operators
    | OpEq | OpNeq | OpLt | OpLte | OpGt | OpGte | KwIn
    // Logical operators
    | OpAnd | OpOr | OpNot

    // Punctuation
    | Dot | Comma | Colon | SemiColon | Hash | Pipe | Arrow

    // Pairwise
    | OpenParen | CloseParen
    | OpenBrace | CloseBrace
    | OpenBracket | CloseBracket

    // Keywords
    | KwImport
    | KwType | KwTrait | KwFunc | KwVar | KwVal
    | KwIf | KwElse | KwFor | KwWhile | KwReturn | KwMatch | KwGoto | KwThrow
    | KwCast | KwThis | KwImpl
    | KwTrue | KwFalse

    // Names and literals
    | Discard
    | Name
    | LitInt | LitChar
    // String literal components
    | LitStrStart | LitStrEnd
    | LitStrElement | LitStrInterpolateName
    | LitStrInterpolateStart
    ;

#[derive(ToString)]
type Token(val Text: string, val Kind: TokenType);

#[derive(Equatable, ToString)]
type LexerMode =
    | Normal
    | String
    ;

type Lexer(
    val Text: string,
    var Offset: int,
    var ModeStack: Stack[LexerMode]);

impl Lexer {
    // TODO: We shouldn't return a List here, it should rather be some lazy
    // sequence, like a generator
    func tokenize(text: string): List[Token] {
        val lexer = Lexer.new(text);
        val tokens = List[Token]();
        while (true) {
            val token = lexer.next();
            tokens.Add(token);
            // NOTE: It would really help to have == operator for types that
            // derive Equatable
            if (token.Kind.Equals(TokenType.End)) goto break;
        }
        return tokens;
    }

    // NOTE: Named arguments would be really nice here
    // Maybe Lexer(Text = text, Offset = 0) ?
    func new(text: string): Lexer {
        val stk = Stack[LexerMode]();
        stk.Push(LexerMode.Normal);
        return Lexer(text, 0, stk);
    }

    func next(this): Token {
    begin:
        var start = this.Offset;

        func is_end(): bool = this.Offset >= this.Text.Length;
        func current(): char = this.Text[this.Offset];
        func step() = this.Offset += 1;

        func consume_while(pred: (char) -> bool) {
            while (not is_end() and pred(current())) step();
        }

        func take(ty: TokenType): Token {
            val text = this.Text.Substring(start, this.Offset - start);
            return Token(text, ty);
        }

        func matches(text: string): bool {
            if (this.Offset + text.Length > this.Text.Length) return false;
            for (i in Range(0, text.Length)) {
                if (text[i] != this.Text[this.Offset + i]) return false;
            }
            this.Offset += text.Length;
            return true;
        }

        func is_ident(ch: char): bool = char.IsLetterOrDigit(ch) or ch == '_';
        func is_end_of_line(ch: char): bool = ch == '\n' or ch == '\r';
        func is_str_element(ch: char): bool =
            not char.IsControl(ch) and ch != '$' and ch != '\\' and ch != '"';
        func is_escape(ch: char, additional: string): bool =
            "abfnrtv\\".Contains(ch) or additional.Contains(ch);
        func is_space(ch: char): bool =
            ch != '\r' and ch != '\n' and char.IsWhiteSpace(ch);
        func negate(pred: (char) -> bool): (char) -> bool {
            func f(ch: char): bool = not pred(ch);
            return f;
        }

        // EOF
        if (is_end()) return take(TokenType.End);

        match (this.ModeStack.Peek()) {
        | LexerMode.Normal -> goto next_normal;
        | LexerMode.String -> goto next_string;
        | _ -> throw NotImplementedException("Lexer mode ${this.ModeStack.Peek()} is not supported!");
        }

    next_normal:
        // Newline
        if (current() == '\r') {
            step();
            if (not is_end() and current() == '\n') step();
            return take(TokenType.Newline);
        }
        if (current() == '\n') {
            step();
            return take(TokenType.Newline);
        }

        // Space
        if (is_space(current())) {
            consume_while(is_space);
            return take(TokenType.Whitespace);
        }

        // Line comment
        if (matches("//")) {
            consume_while(negate(is_end_of_line));
            return take(TokenType.LineComment);
        }

        // Two-character tokens are handled first, so one character tokens won't
        // split them
        if (matches("==")) return take(TokenType.OpEq);
        if (matches("!=")) return take(TokenType.OpNeq);
        if (matches(">=")) return take(TokenType.OpGte);
        if (matches("<=")) return take(TokenType.OpLte);
        if (matches("+=")) return take(TokenType.OpAddAsgn);
        if (matches("-=")) return take(TokenType.OpSubAsgn);
        if (matches("*=")) return take(TokenType.OpMulAsgn);
        if (matches("/=")) return take(TokenType.OpDivAsgn);
        if (matches("->")) return take(TokenType.Arrow);

        // Integer literal
        if (char.IsDigit(current())) {
            consume_while(char.IsDigit);
            return take(TokenType.LitInt);
        }

        // Identifier-like tokens
        if (is_ident(current())) {
            consume_while(is_ident);
            val result = take(TokenType.Name);
            val kind = match (result.Text) {
            | "import" -> TokenType.KwImport
            | "func" -> TokenType.KwFunc
            | "var" -> TokenType.KwVar
            | "val" -> TokenType.KwVal
            | "type" -> TokenType.KwType
            | "trait" -> TokenType.KwTrait
            | "this" -> TokenType.KwThis
            | "return" -> TokenType.KwReturn
            | "goto" -> TokenType.KwGoto
            | "throw" -> TokenType.KwThrow
            | "for" -> TokenType.KwFor
            | "impl" -> TokenType.KwImpl
            | "if" -> TokenType.KwIf
            | "else" -> TokenType.KwElse
            | "while" -> TokenType.KwWhile
            | "match" -> TokenType.KwMatch
            | "cast" -> TokenType.KwCast
            | "in" -> TokenType.KwIn
            | "true" -> TokenType.KwTrue
            | "false" -> TokenType.KwFalse
            | "mod" -> TokenType.OpMod
            | "rem" -> TokenType.OpRem
            | "and" -> TokenType.OpAnd
            | "or" -> TokenType.OpOr
            | "not" -> TokenType.OpNot
            | "_" -> TokenType.Discard
            | _ -> TokenType.Name
            };
            return Token(result.Text, kind);
        }

        // Char literal
        if (current() == '\'') {
            step();
            // TODO: Error reporting?
            if (is_end()) return take(TokenType.Unknown);
            if (current() == '\\') {
                step();
                // TODO: Error reporting?
                if (is_end()) return take(TokenType.Unknown);
                val escaped = current();
                step();
                // TODO: Error reporting?
                if (not is_escape(escaped, "'")) return take(TokenType.Unknown);
            }
            else if (not char.IsControl(current())) {
                step();
            }
            else {
                // TODO: Error reporting?
                return take(TokenType.Unknown);
            }
            // TODO: Error reporting?
            if (is_end()) return take(TokenType.Unknown);
            // TODO: Error reporting?
            if (current() != '\'') return take(TokenType.Unknown);
            step();
            return take(TokenType.LitChar);
        }

        // Single-letter
        val ch = current();
        step();
        val ty = match (ch) {
        | '+' -> TokenType.OpAdd
        | '-' -> TokenType.OpSub
        | '*' -> TokenType.OpMul
        | '/' -> TokenType.OpDiv
        | '=' -> TokenType.OpAsgn
        | '>' -> TokenType.OpGt
        | '<' -> TokenType.OpLt
        | '.' -> TokenType.Dot
        | ',' -> TokenType.Comma
        | ':' -> TokenType.Colon
        | ';' -> TokenType.SemiColon
        | '#' -> TokenType.Hash
        | '|' -> TokenType.Pipe
        | '(' -> TokenType.OpenParen
        | ')' -> TokenType.CloseParen
        | '[' -> TokenType.OpenBracket
        | ']' -> TokenType.CloseBracket
        | '{' -> { this.ModeStack.Push(LexerMode.Normal); TokenType.OpenBrace }
        | '}' -> { this.ModeStack.Pop(); TokenType.CloseBrace }
        | '"' -> { this.ModeStack.Push(LexerMode.String); TokenType.LitStrStart }
        // TODO: Error reporting?
        | _ -> TokenType.Unknown
        };
        return take(ty);

    next_string:
        if (current() == '"') {
            this.ModeStack.Pop();
            step();
            return take(TokenType.LitStrEnd);
        }
        if (current() == '$') {
            step();
            // If we have reached the EOF, we just return it as an element
            if (is_end()) return take(TokenType.LitStrElement);
            // Otherwise, we can have an open curly or an identifier
            if (is_ident(current())) {
                consume_while(is_ident);
                return take(TokenType.LitStrInterpolateName);
            }
            if (current() == '{') {
                step();
                this.ModeStack.Push(LexerMode.Normal);
                return take(TokenType.LitStrInterpolateStart);
            }
            // Just a $ element
            return take(TokenType.LitStrElement);
        }
        if (current() == '\\') {
            step();
            // TODO: Error reporting?
            if (is_end()) return take(TokenType.Unknown);
            val escaped = current();
            step();
            // TODO: Error reporting?
            if (not is_escape(escaped, "\"$")) return take(TokenType.Unknown);
            return take(TokenType.LitStrElement);
        }
        if (is_str_element(current())) {
            consume_while(is_str_element);
            return take(TokenType.LitStrElement);
        }
        // If it's a newline, we pop the stack to so into normal mode
        if (current() == '\r' or current() == '\n') {
            this.ModeStack.Pop();
            goto begin;
        }
        // TODO: Error reporting?
        step();
        return take(TokenType.Unknown);
    }
}
